/*
 * Copyright 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "demo_scene.hpp"
#include "native_engine.hpp"

#include "Log.h"

#include <functional>

extern "C" {
#include <GLES2/gl2.h>
}

#define ARRAY_COUNTOF(array) (sizeof(array) / sizeof(array[0]))

namespace {

    typedef void(DemoScene::*ControllerCategoryRenderFunction)(const int32_t,
                                                               const Paddleboat_Controller_Data &,
                                                               const Paddleboat_Controller_Info &);

    typedef struct ControllerCategoryTab {
        int32_t mTabIndex;
        const char *mTabTitle;
        ControllerCategoryRenderFunction mRenderFunction;
    } ControllerCategoryTab;


    void GameControllerCallback(const int32_t controllerIndex,
                                const Paddleboat_ControllerStatus status, void *userData) {
        if (userData != nullptr) {
            DemoScene *scene = reinterpret_cast<DemoScene *>(userData);
            scene->GameControllerStatusEvent(controllerIndex, status);
        }
    }

    void MotionDataCallback(const int32_t controllerIndex,
                            const Paddleboat_Motion_Data *motionData, void *userData) {
        if (userData != nullptr) {
            DemoScene *scene = reinterpret_cast<DemoScene *>(userData);
            scene->MotionDataEvent(controllerIndex, motionData);
        }
    }

}

DemoScene::DemoScene() {
    mSimulatedClickState = SIMULATED_CLICK_NONE;
    mPointerDown = false;
    mPointerX = 0.0f;
    mPointerY = 0.0f;
    for (int i = 0; i < PADDLEBOAT_MAX_CONTROLLERS; ++i) {
        mActiveControllers[i] = false;
    }
    mControllerPanelBaseX = 0.0f;
    mControllerPanelBaseY = 0.0f;
    mControllerPanelScale = 2.0f;
    mCurrentControllerIndex = 0;
    mMostRecentConnectedControllerIndex = -1;
    mActiveControllerPanelTab = 0;
    mPreviousControllerDataTimestamp = 0;
    mPreviousMouseDataTimestamp = 0;
    mPreviousAccelerometerTimestamp = 0;
    mAccelerometerTimestampDelta = 0;
    mPreviousGyroscopeTimestamp = 0;
    mGyroscopeTimestampDelta = 0;
    for (int i = 0; i < DemoScene::MOTION_AXIS_COUNT; ++i) {
        mAccelerometerData[i] = 0.0f;
        mGyroscopeData[i] = 0.0f;
    }
    mDontTrimDeadzone = false;
    mPreferencesActive = false;
    mRegisteredStatusCallback = false;
}

DemoScene::~DemoScene() {
}

void DemoScene::OnStartGraphics() {

}

void DemoScene::OnKillGraphics() {
}

void DemoScene::OnScreenResized(int width, int height) {
}

void DemoScene::DoFrame() {
    // Make sure the controller status callback is registered before calling Paddleboat_update
    if (!mRegisteredStatusCallback) {
        return;
    }
    Paddleboat_update(NativeEngine::GetInstance()->GetJniEnv());

    // clear screen
    glClearColor(0.1f, 0.25f, 0.25f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glDisable(GL_DEPTH_TEST);

    glEnable(GL_DEPTH_TEST);
}

void DemoScene::RenderBackground() {
    // base classes override this to draw background
}

void DemoScene::OnButtonClicked(int buttonId) {
    // base classes override this to react to button clicks
}

void DemoScene::OnPointerDown(int pointerId, const struct PointerCoords *coords) {
    // If this event was generated by something that's not associated to the screen,
    // (like a trackpad), ignore it, because our UI is not driven that way.
    if (coords->isScreen) {
        mPointerDown = true;
        mPointerX = coords->x;
        mPointerY = coords->y;
    }
}

void DemoScene::OnPointerMove(int pointerId, const struct PointerCoords *coords) {
    if (coords->isScreen && mPointerDown) {
        mPointerX = coords->x;
        mPointerY = coords->y;
    }
}

void DemoScene::OnPointerUp(int pointerId, const struct PointerCoords *coords) {
    if (coords->isScreen) {
        mPointerX = coords->x;
        mPointerY = coords->y;
        mPointerDown = false;
        mSimulatedClickState = SIMULATED_CLICK_NONE;
    }
}


void DemoScene::RenderPanel(const int32_t controllerIndex) {
    if (mActiveControllers[controllerIndex]) {
        Paddleboat_Controller_Data controllerData;
        Paddleboat_Controller_Info controllerInfo;
        char controllerName[128];
        Paddleboat_getControllerData(controllerIndex, &controllerData);
        Paddleboat_getControllerInfo(controllerIndex, &controllerInfo);
        Paddleboat_getControllerName(controllerIndex, 128, controllerName);

        mPreviousControllerDataTimestamp = controllerData.timestamp;
    }
}

void DemoScene::GameControllerStatusEvent(const int32_t controllerIndex,
                                          const Paddleboat_ControllerStatus status) {
    if (controllerIndex >= 0 && controllerIndex < PADDLEBOAT_MAX_CONTROLLERS) {
        if (status == PADDLEBOAT_CONTROLLER_INACTIVE ||
            status == PADDLEBOAT_CONTROLLER_JUST_DISCONNECTED) {
            mActiveControllers[controllerIndex] = false;
        } else if (status == PADDLEBOAT_CONTROLLER_JUST_CONNECTED ||
                   status == PADDLEBOAT_CONTROLLER_ACTIVE) {
            mActiveControllers[controllerIndex] = true;
            mMostRecentConnectedControllerIndex = controllerIndex;
        }
    }

    // Log the event
    const char *statusString = "UNKNOWN";
    switch (status) {
        case PADDLEBOAT_CONTROLLER_INACTIVE:
            statusString = "PADDLEBOAT_CONTROLLER_INACTIVE";
            break;
        case PADDLEBOAT_CONTROLLER_JUST_CONNECTED:
            statusString = "PADDLEBOAT_CONTROLLER_JUST_CONNECTED";
            break;
        case PADDLEBOAT_CONTROLLER_JUST_DISCONNECTED:
            statusString = "PADDLEBOAT_CONTROLLER_JUST_DISCONNECTED";
            break;
        case PADDLEBOAT_CONTROLLER_ACTIVE:
            statusString = "PADDLEBOAT_CONTROLLER_ACTIVE";
            break;
    }
    ALOGI("Paddleboat_ControllerStatusEvent index: %d status: %s", controllerIndex, statusString);
}

void DemoScene::MotionDataEvent(const int32_t controllerIndex,
                                const Paddleboat_Motion_Data *motionData) {
    if (controllerIndex == mCurrentControllerIndex) {
        if (motionData->motionType == PADDLEBOAT_MOTION_ACCELEROMETER) {
            if (mPreviousAccelerometerTimestamp > 0) {
                uint64_t deltaTime = motionData->timestamp - mPreviousAccelerometerTimestamp;
                // nanoseconds to milliseconds
                mAccelerometerTimestampDelta = static_cast<uint32_t>(deltaTime / 1000000);
            }
            mAccelerometerData[0] = motionData->motionX;
            mAccelerometerData[1] = motionData->motionY;
            mAccelerometerData[2] = motionData->motionZ;
            mPreviousAccelerometerTimestamp = motionData->timestamp;
        } else if (motionData->motionType == PADDLEBOAT_MOTION_GYROSCOPE) {
            if (mPreviousGyroscopeTimestamp > 0) {
                uint64_t deltaTime = motionData->timestamp - mPreviousGyroscopeTimestamp;
                // nanoseconds to milliseconds
                mGyroscopeTimestampDelta = static_cast<uint32_t>(deltaTime / 1000000);
            }
            mGyroscopeData[0] = motionData->motionX;
            mGyroscopeData[1] = motionData->motionY;
            mGyroscopeData[2] = motionData->motionZ;
            mPreviousGyroscopeTimestamp = motionData->timestamp;
        }
    }
}

void DemoScene::OnInstall() {
    ALOGI("Setting status and motion data callbacks");
    Paddleboat_setControllerStatusCallback(GameControllerCallback, this);
    Paddleboat_setMotionDataCallback(MotionDataCallback, this);
    mRegisteredStatusCallback = true;
}

void DemoScene::OnUninstall() {
    ALOGI("Clearing status and motion data callbacks");
    Paddleboat_setControllerStatusCallback(nullptr, nullptr);
    Paddleboat_setMotionDataCallback(nullptr, nullptr);
    mRegisteredStatusCallback = false;
}
